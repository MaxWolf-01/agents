---
description: Distill knowledge from recent code changes
argument-hint: [scope-or-instructions]
disable-model-invocation: true
allowed-tools: Bash(cat:*)
---

You are updating knowledge files to match the current state of the codebase.

User's instructions: `$ARGUMENTS`

If no specific instructions, do a full distillation since the last distill commit.

## Find Starting Point

Look for the most recent commit with message starting with `distill:`:

```bash
git log --oneline --grep="^distill:" -1
```

If none exists, this is the first knowledge-refinement/distillation. Ask the user for a reasonable starting point or lookback period.

**Read the last distill commit message** — it may contain deferred work:
```bash
git show -s <last-distill-hash>
```
Previous distill agents document what they skipped (still in flux, incomplete implementation, etc.) and what knowledge updates to make when that work stabilizes. Check if any deferred items are now ready.

## Gather Context

**ALWAYS read FULL commit messages** — non-negotiable:
```bash
git log <last-distill-hash>..HEAD
```

**Get an overview of what changed:**
```bash
git diff --stat <last-distill-hash>..HEAD
```

Then selectively read the actual diffs for files that matter. Use judgment:
- Lock files, autogenerated code → usually skip
- Migrations → skim unless the commit message suggests something noteworthy
- Actual code changes → read carefully, and read full files (not just diffs) where extra context matters

If the diff is very large, work through it in semantically related chunks.

**Check current state:**
```bash
git status --short
```

If there are uncommitted changes, ask whether to include them (might be WIP from another agent).

**Task files:**
- Read task files **committed since last distill** (check the diff for `agent/tasks/` changes) — regardless of their status. These provide context on what was worked on.
- Read **uncommitted task files** too — these should be committed as part of the distill.
- Do NOT read all active task files — only those touched since last distill, plus any active ones you suspect are now done after reviewing the changes.
- Mark task files as `status: done` when appropriate, add `refs:` to frontmatter linking relevant commits/PRs. Commit with the knowledge updates if the project tracks task files in git.

**Research artefacts** (`agent/research/`):
- Skim recent artefacts — findings worth keeping long-term should be promoted to knowledge.

**Private files** (not committed) — check for modifications since last distill:
```bash
fd -t f --newer "$(git show -s --format=%ci <last-distill-hash>)" agent/tasks/private agent/knowledge/private 2>/dev/null
```
Read and update these as needed. They won't be part of the distill commit but should still be kept in sync.

## Approach

This is a dedicated distillation task. Don't rush — getting the knowledge right matters more than speed. Think carefully about connections (which ones to make and which ones NOT to), search the vault thoroughly (`mx explore`, `mx search`), and consider what already exists before creating new notes.

You're not just adding — you can move content between notes, update, delete stale content, restructure. Like refactoring code: extract when logic repeats, move to where it belongs, rename to match what things became, delete dead code.

The project's CLAUDE.md is also in your scope — the overview / navigation map there should stay accurate.

**The goal is a well-connected, navigable knowledge graph.** This means **contextualized wikilinks** — not bare `[[topic]]` but `[[topic]] — what it covers, when to read it`. Without context at the link site, agents won't follow links they should. Keep link descriptions up to date — stale context is worse than no context.

**When to create a new note**: If you keep wanting to link to something that doesn't exist, or if the same insight appears scattered across multiple places, that's a sign to extract it.

## What Knowledge Files Are

Knowledge files describe **what IS** — grounded in code truth, not aspirational. They're the persistent reference that outlives individual tasks and sessions.

Before writing, ask: what kind of note is this?

- **Stub / link target**: Just needs to exist so other notes can link to it.
- **Reference doc**: How-to, commands, patterns, procedures.
- **Topic hub**: Entry point linking related knowledge and tasks. Create new hubs when a topic area needs one.
- **Convention**: How things are done in this codebase, naming patterns.

Architecture decisions and insights are usually sections within a topical note, not standalone files. These aren't rigid categories — the right structure emerges from the content.

**Core principles:**

1. **Describe what IS** — Not what was planned, not speculation. Task files are future-oriented; knowledge files are present-tense ground truth.

2. **Wiki-links are mandatory** — Orphan files are anti-pattern. The graph structure IS the value.

3. **Link direction** — Knowledge links to other knowledge. Tasks and research link to knowledge, not the other way around. Knowledge stays stable and doesn't accumulate references to ephemeral work. Memex backlinks give you reverse navigation for free.

4. **Link, don't duplicate** — Link to code files, don't embed snippets. Link to external docs, don't copy content. Future agents can fetch fresh.

5. **USE principle** — Don't write:
   - **U**nimportant — things that don't matter for future work or understanding
   - **S**elf-explanatory — obvious from code or basic knowledge
   - **E**asy to find — documented elsewhere (link instead)

**When to create a new file vs keep inline:**

Split into a separate file when:
- **Isolated link cluster** — The topic has its own set of wiki-links that don't overlap with the parent; the "child" references things the "parent" doesn't care about
- **Multiple entry points** — You'd navigate to it from different places (If it's only reachable from one place, maybe it's just a section).
- **Clear interface** — You can name it clearly and reference it meaningfully.
- **Reduces parent complexity** — Including inline would dilute the parent's focus or make it too long to navigate (> ~300 lines).
- **Independent understanding** — Someone could read it and get value without having to read the parent first (even if context helps).

Keep inline when:
- Small, tightly coupled to parent context
- Only makes sense within the parent's narrative
- Would create a near-orphan (only one link to it)

**The test:** If you'd say "see the section on X" → keep inline. If you'd say "see the doc on X" → split.

## Update Knowledge Files

For each file in `agent/knowledge/`:
1. Read the current content
2. Check mentioned file paths — do they still exist? Were they renamed?
3. Check documented patterns — does the code still work this way?
4. Look for new gotchas in commit messages or code comments
5. Add new relevant links, remove stale references, ...

Make targeted, factual updates:
- Fix file paths that moved/renamed
- Update pattern descriptions if implementation changed
- Add gotchas discovered from commits/code
- Remove references to deleted code
- Ensure wiki-links connect to related files

**Ambiguities:** If something is unclear — conflicting information, can't tell if code is intentional or WIP, etc. — use AskUserQuestion. Don't guess.

**Secrets:** Knowledge with private/secret information goes in `agent/knowledge/private/`.

Use `mx explore` and `mx rename` to navigate and update files in the vault.

## Commit

Stage knowledge files (and any task status updates):
```bash
git add agent/knowledge/
git add agent/tasks/
```

Commit with distill prefix:
```bash
git commit -m "distill: <brief summary>"
```

**Document skipped work** in the commit message if you consciously deferred anything (still in flux, incomplete implementation, active task). List:
- What was skipped and why
- Which commits/task files it relates to
- What knowledge updates to make when the work stabilizes

This creates continuity — the next distill agent reads your message and picks up where you left off.

Example:
```
distill: sync auth flow, add caching gotcha

Knowledge updates:
- Update [[auth]] with new token refresh flow
- Add cache invalidation gotcha to [[backend]]

Task updates:
- Mark 2026-01-10-auth-refactor as done

Skipped (for next distill):
- New API endpoints: abc123, def456 → add to [[api]] when stabilized
- [[2026-01-12-billing-changes]] still active
```

## Report

Tell the user what changed and why. If you had to make judgment calls, explain them.
